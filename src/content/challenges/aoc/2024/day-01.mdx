---
title: "Day 1: Historian Hysteria"
date: "2024-12-01"
description: "Advent of Code 2024 Day 1 - Sorting and calculating distances between location lists"
tags: ["Advent of Code", "Sorting", "Arrays", "TypeScript"]
category: "aoc"
readingTime: "5 min read"
year: 2024
day: 1
difficulty: "Easy"
---

## Problem Overview

The Chief Historian is missing, and the Senior Historians need help reconciling their location lists. We need to pair up locations from two lists and calculate the total distance between them.

## Part 1: Total Distance

Given two lists of location IDs, pair them up by sorting both lists and matching the smallest with the smallest, second smallest with second smallest, and so on.

### Example

```
Left list:  3, 4, 2, 1, 3, 3
Right list: 4, 3, 5, 3, 9, 3

Sorted:
Left:  1, 2, 3, 3, 3, 4
Right: 3, 3, 3, 4, 5, 9

Pairs: (1,3), (2,3), (3,3), (3,4), (3,5), (4,9)
Distances: 2, 1, 0, 1, 2, 5
Total: 11
```

### Solution

```typescript
function calculateTotalDistance(left: number[], right: number[]): number {
  const sortedLeft = [...left].sort((a, b) => a - b);
  const sortedRight = [...right].sort((a, b) => a - b);

  let totalDistance = 0;

  for (let i = 0; i < sortedLeft.length; i++) {
    totalDistance += Math.abs(sortedLeft[i] - sortedRight[i]);
  }

  return totalDistance;
}
```

## Part 2: Similarity Score

Calculate a similarity score by multiplying each number in the left list by the number of times it appears in the right list.

### Solution

```typescript
function calculateSimilarityScore(left: number[], right: number[]): number {
  const rightCount = new Map<number, number>();

  // Count occurrences in right list
  for (const num of right) {
    rightCount.set(num, (rightCount.get(num) || 0) + 1);
  }

  let similarityScore = 0;

  // Calculate similarity score
  for (const num of left) {
    const count = rightCount.get(num) || 0;
    similarityScore += num * count;
  }

  return similarityScore;
}
```

## Complete Solution

```typescript
function day1Solution(input: string): { part1: number; part2: number } {
  const lines = input.trim().split('\n');
  const left: number[] = [];
  const right: number[] = [];

  for (const line of lines) {
    const [leftNum, rightNum] = line.trim().split(/\s+/).map(Number);
    left.push(leftNum);
    right.push(rightNum);
  }

  const part1 = calculateTotalDistance(left, right);
  const part2 = calculateSimilarityScore(left, right);

  return { part1, part2 };
}
```

## Key Insights

1. **Sorting**: Part 1 requires sorting both lists to pair elements optimally
2. **Frequency counting**: Part 2 uses a Map to efficiently count occurrences
3. **Time complexity**: O(n log n) for Part 1 due to sorting, O(n) for Part 2
4. **Space complexity**: O(n) for both parts

This problem is a great warm-up for Advent of Code, introducing fundamental concepts like sorting and frequency counting that often appear in later challenges.