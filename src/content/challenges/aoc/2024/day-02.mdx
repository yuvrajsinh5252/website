---
title: "Day 2: Red-Nosed Reports"
date: "2024-12-02"
description: "Advent of Code 2024 Day 2 - Analyzing reactor safety reports for safe and unsafe levels"
tags: ["Advent of Code", "Arrays", "Validation", "TypeScript"]
category: "aoc"
readingTime: "6 min read"
year: 2024
day: 2
difficulty: "Easy"
---

## Problem Overview

The engineers need to analyze reactor safety reports to determine which ones are safe. A report is safe if:
- All levels are either increasing or decreasing
- Any two adjacent levels differ by at least 1 and at most 3

## Part 1: Basic Safety Check

### Example

```
7 6 4 2 1  -> Safe (decreasing by 1-2)
1 2 7 8 9  -> Unsafe (2->7 increases by 5)
9 7 6 2 1  -> Unsafe (6->2 decreases by 4)
1 3 2 4 5  -> Unsafe (mixed increase/decrease)
8 6 4 4 1  -> Unsafe (4->4 no change)
1 3 6 7 9  -> Safe (increasing by 1-3)
```

### Solution

```typescript
function isSafeReport(levels: number[]): boolean {
  if (levels.length < 2) return true;

  let isIncreasing = true;
  let isDecreasing = true;

  for (let i = 1; i < levels.length; i++) {
    const diff = levels[i] - levels[i - 1];

    // Check if difference is within valid range
    if (Math.abs(diff) < 1 || Math.abs(diff) > 3) {
      return false;
    }

    // Track direction
    if (diff > 0) isDecreasing = false;
    if (diff < 0) isIncreasing = false;
  }

  return isIncreasing || isDecreasing;
}
```

## Part 2: Problem Dampener

The Problem Dampener allows removing a single level from any unsafe report to potentially make it safe.

### Solution

```typescript
function isSafeWithDampener(levels: number[]): boolean {
  // First check if it's already safe
  if (isSafeReport(levels)) return true;

  // Try removing each level one by one
  for (let i = 0; i < levels.length; i++) {
    const modifiedLevels = levels.filter((_, index) => index !== i);
    if (isSafeReport(modifiedLevels)) {
      return true;
    }
  }

  return false;
}
```

## Complete Solution

```typescript
function day2Solution(input: string): { part1: number; part2: number } {
  const reports = input.trim().split('\n').map(line =>
    line.trim().split(' ').map(Number)
  );

  const part1 = reports.filter(isSafeReport).length;
  const part2 = reports.filter(isSafeWithDampener).length;

  return { part1, part2 };
}
```

## Optimized Solution

For better performance, we can optimize the dampener check:

```typescript
function isSafeWithDampenerOptimized(levels: number[]): boolean {
  if (isSafeReport(levels)) return true;

  // Find the first problematic position
  for (let i = 1; i < levels.length; i++) {
    const diff = levels[i] - levels[i - 1];

    if (Math.abs(diff) < 1 || Math.abs(diff) > 3) {
      // Try removing either the current or previous element
      return isSafeReport(levels.filter((_, idx) => idx !== i)) ||
             isSafeReport(levels.filter((_, idx) => idx !== i - 1));
    }
  }

  // Check for direction changes
  let changes = 0;
  let changeIndex = -1;

  for (let i = 2; i < levels.length; i++) {
    const prev = levels[i - 1] - levels[i - 2];
    const curr = levels[i] - levels[i - 1];

    if ((prev > 0 && curr < 0) || (prev < 0 && curr > 0)) {
      changes++;
      changeIndex = i;
    }
  }

  if (changes === 1) {
    // Try removing elements around the direction change
    for (let i = Math.max(0, changeIndex - 1); i <= Math.min(levels.length - 1, changeIndex + 1); i++) {
      if (isSafeReport(levels.filter((_, idx) => idx !== i))) {
        return true;
      }
    }
  }

  return false;
}
```

## Key Insights

1. **Validation logic**: Check both difference constraints and direction consistency
2. **Brute force approach**: For Part 2, trying all possible removals is straightforward
3. **Optimization opportunities**: Can optimize by identifying problematic positions first
4. **Edge cases**: Handle single-element and two-element arrays properly

This problem introduces important concepts like validation logic and the "try all possibilities" approach that's common in competitive programming.